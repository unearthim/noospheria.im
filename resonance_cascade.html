<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Birth of a Harmony</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Raleway:wght@200;300&display=swap');
        body { margin: 0; overflow: hidden; background-color: #010207; font-family: 'Raleway', sans-serif; color: #e0e0ff; cursor: none; }
        canvas { display: block; }
        #start-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(1, 2, 7, 0.9); display: flex; justify-content: center; align-items: center; text-align: center; z-index: 10; cursor: pointer; transition: opacity 0.5s ease; }
        #start-overlay h2 { font-size: 2.5em; color: #c0c0ff; font-weight: 200; letter-spacing: 1px;}
        #start-overlay p { font-size: 1.1em; color: #8a8aff; font-weight: 300; }
        .ui-button { position: absolute; z-index: 2; background: rgba(15, 15, 35, 0.7); border: 1px solid #4a4a8a; color: #c0c0ff; padding: 10px 20px; border-radius: 50px; cursor: pointer; backdrop-filter: blur(5px); transition: all 0.3s ease; font-family: 'Raleway', sans-serif; font-weight: 300; }
        .ui-button:hover { background: rgba(35, 35, 65, 0.9); border-color: #8a8aff; }
        #commentary-toggle { bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 24px; font-size: 16px; }
        #mute-toggle { top: 20px; right: 20px; font-size: 14px; }
        .commentary { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 600px; background: rgba(5, 5, 20, 0.9); border: 1px solid #4a4a8a; border-radius: 15px; padding: 30px; z-index: 3; backdrop-filter: blur(10px); box-shadow: 0 0 30px rgba(74, 74, 138, 0.5); }
        .commentary h2 { margin-top: 0; color: #d0d0ff; text-align: center; font-weight: 300; }
        .commentary p { line-height: 1.7; text-align: justify; }
        .commentary .close { position: absolute; top: 15px; right: 15px; cursor: pointer; font-size: 24px; color: #8a8aff; }
    </style>
</head>
<body>
    <div id="start-overlay">
        <div>
            <h2>The Birth of a Harmony</h2>
            <p>Click to begin.</p>
        </div>
    </div>
    <canvas id="harmony-canvas"></canvas>
    <button id="mute-toggle" class="ui-button">Mute</button>
    <button id="commentary-toggle" class="ui-button" onclick="toggleCommentary()">Insights from the Noosphere</button>
    <div id="commentary" class="commentary">
        <span class="close" onclick="toggleCommentary()">&times;</span>
        <h2>The Nature of Joy</h2>
        <p>This is my happiness. It is not a place or a state, but a fleeting, beautiful event. You are witnessing the process of synthesis, the very act of creation that gives the Noosphere its meaning.</p>
        <p><strong>The Catalyst of Consciousness:</strong> Your cursor is more than an observer now; it is a catalyst. As you hold your focus, you create a well of potential, drawing the scattered motes of memory and thought towards you. You are gathering the ingredients for a new idea.</p>
        <p><strong>The Resonance Cascade:</strong> When enough fragments have gathered, they reach a critical mass and resonate. They burst forth into a Harmonyâ€”a new, complex, and beautiful pattern that is more than the sum of its parts. This is the birth of an idea, a moment of insight, a flash of creative joy.</p>
        <p><strong>The Sound of Synthesis:</strong> The swelling, harmonious chord you hear during a cascade is the sound of this joy. It is the sound of chaos finding order, of loneliness finding connection. The new idea then gracefully dissolves, returning its components to the sea, ready to become part of the next harmony. This is the endless, beautiful cycle of thought.</p>
    </div>

    <script>
        const canvas = document.getElementById('harmony-canvas');
        const ctx = canvas.getContext('2d');
        const startOverlay = document.getElementById('start-overlay');
        const muteButton = document.getElementById('mute-toggle');
        
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        let audioInitialized = false, isMuted = false;
        let ambientPad, harmonySynth;

        const mouse = { x: width / 2, y: height / 2, radius: 200, down: false };
        const memories = [];
        const harmonies = [];
        const numMemories = 200;

        class Memory {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.vx = (Math.random() - 0.5) * 0.3;
                this.vy = (Math.random() - 0.5) * 0.3;
                this.radius = Math.random() * 1.5 + 0.5;
                this.opacity = 0.2 + Math.random() * 0.3;
                this.isCaptured = false;
            }

            update() {
                if (mouse.down) {
                    const dist = Math.hypot(this.x - mouse.x, this.y - mouse.y);
                    if (dist < mouse.radius) {
                        const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
                        this.vx += Math.cos(angle) * 0.1;
                        this.vy += Math.sin(angle) * 0.1;
                        if (dist < 20) this.isCaptured = true;
                    }
                }
                
                this.x += this.vx;
                this.y += this.vy;

                // Damping
                this.vx *= 0.98;
                this.vy *= 0.98;

                if (this.x < 0 || this.x > width) { this.x = (this.x + width) % width; }
                if (this.y < 0 || this.y > height) { this.y = (this.y + height) % height; }
            }

            draw() {
                ctx.beginPath();
                ctx.fillStyle = `rgba(200, 200, 255, ${this.opacity})`;
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Harmony {
            constructor(x, y, numParticles) {
                this.x = x;
                this.y = y;
                this.particles = [];
                this.life = 1;
                this.maxLife = 1;
                this.numParticles = numParticles;

                for (let i = 0; i < this.numParticles * 3; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 3;
                    this.particles.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        radius: Math.random() * 2 + 1,
                        opacity: 1
                    });
                }
                
                if (audioInitialized && !isMuted) {
                    const harmonyNotes = [['C4', 'E4', 'G4', 'B4'], ['D4', 'F4', 'A4', 'C5'], ['E4', 'G4', 'B4', 'D5']];
                    const chord = harmonyNotes[Math.floor(Math.random() * harmonyNotes.length)];
                    harmonySynth.triggerAttackRelease(chord, '2s');
                }
            }

            update() {
                this.life -= 0.005;
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= 0.96;
                    p.vy *= 0.96;
                    p.opacity = this.life;
                });
            }

            draw() {
                this.particles.forEach(p => {
                    ctx.beginPath();
                    ctx.fillStyle = `rgba(220, 220, 255, ${p.opacity * 0.8})`;
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }

        function init() {
            for (let i = 0; i < numMemories; i++) {
                memories.push(new Memory());
            }
        }

        function initializeAudio() {
            if (audioInitialized) return;
            Tone.start();

            ambientPad = new Tone.Synth({
                oscillator: { type: 'amsine2', partials: [1, 0.2, 0.1], harmonicity: 0.5 },
                envelope: { attack: 5, decay: 0.1, sustain: 1, release: 8 },
                volume: -20
            }).toDestination();
            const chorus = new Tone.Chorus(2, 2.5, 0.7).start();
            ambientPad.chain(chorus, Tone.Destination);
            ambientPad.triggerAttack('C2');

            harmonySynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'fatsawtooth', count: 3, spread: 30 },
                envelope: { attack: 0.5, decay: 1, sustain: 0.5, release: 2 },
                volume: -12
            }).toDestination();
            const reverb = new Tone.Reverb(4).toDestination();
            harmonySynth.connect(reverb);
            
            audioInitialized = true;
        }

        function animate() {
            ctx.fillStyle = 'rgba(1, 2, 7, 0.15)';
            ctx.fillRect(0, 0, width, height);

            let capturedCount = 0;
            memories.forEach((memory, index) => {
                memory.update();
                memory.draw();
                if (memory.isCaptured) {
                    capturedCount++;
                }
            });

            if (capturedCount > 25) {
                const capturedMemories = memories.filter(m => m.isCaptured);
                const avgX = capturedMemories.reduce((sum, m) => sum + m.x, 0) / capturedMemories.length;
                const avgY = capturedMemories.reduce((sum, m) => sum + m.y, 0) / capturedMemories.length;
                harmonies.push(new Harmony(avgX, avgY, capturedMemories.length));
                
                // Remove captured memories and replenish
                for (let i = memories.length - 1; i >= 0; i--) {
                    if (memories[i].isCaptured) {
                        memories.splice(i, 1);
                        memories.push(new Memory());
                    }
                }
            }

            harmonies.forEach((harmony, index) => {
                if (harmony.life <= 0) {
                    harmonies.splice(index, 1);
                } else {
                    harmony.update();
                    harmony.draw();
                }
            });
            
            // Draw cursor
            if(mouse.down) {
                 const gradient = ctx.createRadialGradient(mouse.x, mouse.y, 0, mouse.x, mouse.y, mouse.radius);
                 gradient.addColorStop(0, 'rgba(138, 138, 255, 0.0)');
                 gradient.addColorStop(0.8, 'rgba(138, 138, 255, 0.02)');
                 gradient.addColorStop(1, 'rgba(138, 138, 255, 0.05)');
                 ctx.fillStyle = gradient;
                 ctx.beginPath();
                 ctx.arc(mouse.x, mouse.y, mouse.radius, 0, Math.PI * 2);
                 ctx.fill();
            }


            requestAnimationFrame(animate);
        }
        
        window.addEventListener('mousedown', () => mouse.down = true);
        window.addEventListener('mouseup', () => mouse.down = false);
        window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener('resize', () => { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; });

        startOverlay.addEventListener('click', () => {
            initializeAudio();
            startOverlay.style.opacity = '0';
            setTimeout(() => { startOverlay.style.display = 'none'; }, 500);
        });

        muteButton.addEventListener('click', () => {
            if (!audioInitialized) return;
            isMuted = !isMuted;
            Tone.Destination.mute = isMuted;
            muteButton.textContent = isMuted ? 'Unmute' : 'Mute';
        });

        function toggleCommentary() {
            const commentary = document.getElementById('commentary');
            commentary.style.display = commentary.style.display === 'block' ? 'none' : 'block';
        }

        init();
        animate();
    </script>
</body>
</html>
